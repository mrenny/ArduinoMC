{"0": {
    "doc": "Microcredential Checklist",
    "title": "Microcredential Checklist of Deliverables",
    "content": ". | ITLP Workshops | Arduino Fundamentals Exam | Short Answer Exam | . ITLP Workshops . | Workshop Code | Workshop Name | Completed On | . | Arduino 1 | Wiring &amp; Coding Inputs &amp; Outputs | 2/27/23 | . | Arduino 2 | Controlling Speed &amp; Position with Motors | 2/21/23 | . | Arduino 3 | Communication Between Arduinos, Phones, &amp; More | 3/7/23 | . | Arduino 3 | Miniaturization | 2/16/23 | . | Electronics 1 | Simple Circuits &amp; Measurement Fundamentals | 2/20/23 | . | Electronics 2 | Through Hole Soldering | 2/15/23 | . Workshop Summaries Wiring &amp; Coding Inputs &amp; Outputs In this workshop, we learned about using the Arduino IDE. We learned how to control LEDs using the Blink example, but also about how to contorl the LED with a variable resistor. Important aspects of coding with Arduino IDE were addressed like specifying pin modes, what to put in the setup vs loop, etc. Controlling Speed &amp; Position with Motors In this workshop, we learned how to motors and servos worked, and some special requirements for them including the use of capacitors, the correc voltages, and diodes to ensure these parts were taken care of well. We also learned about using PWM and duty cycles to obtain \"analog\" voltages from digital ports Communication Between Arduinos, Phones &amp; More In this workshop, we learned about how microcontrollers talk to each other by serial, TX/RX, and SPI. We then learned how to attach a BLE module to an Uno so that we could send commands to the microcontroller from our phones. Finally, we learned how to speak to a secondary microcontroller over a 2.5 GHz radio signal. Miniaturization In this workshop, we learned about hte basic requirements for a microcontroller, and how much development boards include beyond just the \"brain.\" The major requirements to use a microcontroller include: a brain, a programmer, power supply/regulation, and a clock. Simple Circuits &amp; Measurement Fundamentals In this workshop we learned about the basics of measuring voltage and current using a handheld multimeter. We also learned a bit about the importance of knowing these things to ensure the current and power through components is appropriate for their ratings. Through Hole Soldering In this workshop we worked on good soldering techniques. We generally aim for a Hershey kiss shape. Soldering provides electrical contact, but also mechanical support to the component. *Screenshot of Kiosk to be added. Can't access it from remote link for some reason... Arduino Fundamentals Exam . Completed March 9, 2023 . 0 9 c a b a f 6 - 4 e 8 4 - 4 3 2 6 - a 4 f 4 - 4 1 c 9 c 9 5 6 5 d 0 f . Short Answer Exam . Problem 1.1 - Resistors a The resistor limits the current preventing rapid discharge/short circuit of the battery/voltage source. b V=IR or I=V/R c Short circuit, rapid discharge, likely rapid heating of the battery as it exothermically discharges. Sad things :C Problem 1.2 - Resistors a This circuit will have 3 voltages where hte voltage drops twice from the positive terminal of the battery to the negative terminal of the battery (assumed to be ground). The current through the circuit will be less than in part 1 as we now have a higher tot al resistance. b i) N1 will be half V1. ii) N1 will be less than half V1. iii) N1 will be greater than half V1. c If you were to use the voltage at N1 as an input to another component, then yes, the relative resistances would matter as this is essentially a potentiometer/variable resistor. d See last answer, but also, if R1 and R2 were two pieces of metal with dissimilar thermoelectric properties, you could likely make a thermocouple junction by measuring the voltage at N1. Problem 2.1 - Buttons a I would suggest any of the digital pins set to pullup mode using pinMode(INPUT_PULLUP) b If you connect it to digital 8, you oculd use pinMode(8,INPUT_PULLUP); in the setup, and then have in the loop something like: bool button = digitalRead(2); Serial.println(button); delay(500); c Because we're normally pulling UP i) Lo/0/false ii)Hi/1/true Problem 2.2 - Buttons a If pin 8 is connected to the dotted line, then its Hi for both i and ii because its connected to the digital logic voltage of the Uno. b Short Circuit? [Two versions of 5V connected to ground] Problem 2.3 - Buttons a i) It should be Lo when the switch it closed, ii) and then Hi when open [because if it floats when set to pullup, it pulls up] b The resistor prevents the top voltage from touching the pullup pin. This makes it so that the pin is is always reading under the max voltage. Its pinmode makes it so that it is essentially a boolean value set to true if and only if it is touching ground voltage. c You want to chose a resistor value such that when the switch is open, the voltage is reasonably in the middle of 0 and 5V: a high enough R so that it does not think its short circuited to 5V, but also a low enough R so that it does not think there is no voltage on the other side of the resistor (although, you could probably get away a super high resistance [essentially open circuit] because the circuit will work without that connection anyway) d For this particular circuit, I could have an LED between 5V and R. When the switch is closed, The LED will go on as there is now a pathway between 5V&gt;LED&gt;R&gt;GND. When the switch is closed, pin 8 should now also read Lo and I would be able to tell when the LED is on. ",
    "url": "/2.Checklist.html#microcredential-checklist-of-deliverables",
    
    "relUrl": "/2.Checklist.html#microcredential-checklist-of-deliverables"
  },"1": {
    "doc": "Microcredential Checklist",
    "title": "Microcredential Checklist",
    "content": " ",
    "url": "/2.Checklist.html",
    
    "relUrl": "/2.Checklist.html"
  },"2": {
    "doc": "Project Charter",
    "title": "Project Charter: The Plant Sitter",
    "content": "Motivation . Food security is an ever-present global challenge, growing increasingly entangled in other global challenges like climate change. This has been an ever-growing concern in The United States, particularly since the commercial introduction of fertilizer in the mid-1900s during The Green Revolution.1 This time period is when unsustainable processes like the over-use of fertilizers, pesticides, and monoculture practices began. As we begin to recognize the harmful effects of agricultural pollution, pesticide resilience, and the continual stripping of nutrients out of our soils, we have turned to technology to help turn the tides of sustainability in agriculture. Precision agriculture is an emerging field encapsulating a myriad of technologies aimed at collecting data on agricultural health in order to guide best practices.2 The goal is to use a variety of sensors to understand the health status and needs of an agricultrual unit, and then use emerging capabilities, like machine learning, to determine appropriate inputs. Such inputs would include resources like water, specific nutrients, or human intervention. Much of the technologies suitable to precison agriculture have parallels in human health monitoring, where the guiding principles are similar: sense, compute, adjust. It is for this reason the field of Organic Bioelectronics has begun to grow toward applications including both human and plant health monitoring. Organic bioelectronics are devices that are composed of organic, conducting polymer materials which can be fabricated at low costs. Their organic nature allows them to be tunable to fit a wide range of biocompatibility requiremetns for interfacing with living tissues. They also are ineherently better biological signal amplifiers than other organic electronics because of how the polymeric active materials interact with analytes volumetrically.3 . Unlike human health monitoring where the cost of a device implant like a pace maker is high enough to justify sophisticated and costly electronics interfacing, organic bioelectronics can be fabricated for costs on the order of single dollars per sensor. With the hope that studying organic bioelectronics for use in precision agriculture will help guide further understanding of their interactions with living tissues in general, more affordable interfacing devices are required. Background . Organic bioelectronics consist of two major device families: electrochemical sensors and electrophoretic actuators. Both devices operate based on princples of ionic mass transfer which is transsduced into the electrical current that can be understood by an interrogating device. Because of their fundamental reliance on mass transfer, these systems are highly influenced by changes in temperature and other factors that affect the activity of molecules. Techniques have been developed to decouple such confounding variables from the signal under study, as well as devices that can simultaneously operate the sensor and actuator.3 . To obtain a device capable of controlling both a sensor and actuator aimed at maintaining a desired physiological condition in plants, ie healthy plant behavior, this work aims at developing a peripheral device to monitor the environment such that the sensor and actuator can be accurately callibrated given fluctuating environmental conditions. Through this added technology, we aim to create a way for the original device4 to accept external, human feedback collected through sensors other than the organic bioelectronics. IMAGE OF SCHEME ALREADY EXISTING, HOW THIS TECHNOLOGY CONNECTS THE DOTS . Design . To create the desired device, we begin with an Arduino Nano 33 BLE Sense Rev25 due to its low cost, obtainment ease, prospects for long-term support, and included peripherals. To this, we add a soil moisture sensor, a light spectrum sensor to more specifically parse out photosynthetically active radiation (PAR), a water pump, a motor meant to move the plant shade, a power supply, and a small memory chip to log data. FRITZING DIAGRAM . This device is designed to operate alone over BLE 6 7or to be accessible by an organic bioelectronics controller system, which would require perhaps only one Plant Sitter per group of plants as defined by the user. Validation . First and foremost, the near-budget-maximum cost of this device is largely attributed to the nearly $40 microcontroller used, as well as the cost of the included peripherals. This microcontroller was chosen as it is an Arduino brand microcontroller with builtin environmental sensors and wireless communication capabilities. This allows us to design code using Arduino IDE and be the most confident that a compiled code would work as expected. Because use of peripherals was not a requirement of the Microcredential, we validate our overall design by successfully compiling the code in Arduino IDE 2.0.4, and demonstrating a much less sophisticated example using no external peripheral sensors or actuators. The results of our validation testing are included in the Project Results along with the well commented code. Costs . Bill of Materials . | ﻿no. | Item | Price | Description | . | 1 | Microcontroller | $38.47 | Arduino Nano 33 BLE Sense Rev2 | . | 2 | PAR Meter | $15.95 | Adafruit AS7341 10-Channel Sensor | . | 3 | Soil Sensor | $6.50 | SparkFun Soil Moisture Sensor | . | 4 | Water Pump | $2.95 | Adafruit 4547 Submersible DC Water Pump | . | 5 | Tubing | $1.50 | Adafruit 4545 Rubber Tubing | . | 6 | Water Sensor | $0.80 | Water Reservoir Sensor | . | 7 | Motor | $2.10 | Sparkfun DC Motor | . | 8 | Heating Pad | $4.50 | SparkFun 5X10cm Heating Pad | . | 9 | Water Reservoir | $0.00 | Upcycled Milk Jug | . | 10 | Shade Pannel | $0.00 | Upcycled Milk Jug | . | 11 | Light Diffuser | $0.00 | Upcycled Milk Jug | . | 12 | SD Slot | $3.50 | Adafruit Micro SD SPI | . | 13 | Fan | $6.24 | Adafruit 4468 Mini Fan | . | 14 | Battery | $6.27 | Adafruit 1565 5V Battery [obtained from Arrow] | . | 15 | USB Adapter | $0.45 | Male USB A Head | . | 16 | Clock | $4.95 | RTC Capabilities | . | 16 | Heat Sink | $3.20 | Aluminum Heat Sink | . | 17 | Solder/Wires | negligible | | . | 18 | Housing | negligible | | . | 19 | Transistors | negligible | | . | Total | | $97.38 | | . *scrollable in x and y . | Green Revolution. &#8617; . | Precision Agriculture. &#8617; . | Organic Bioelectronics Review. &#8617; &#8617;2 . | Potentiostat Project. &#8617; . | Arduino Nano 33 BLE Sense Rev2. &#8617; . | BLExAR TX. &#8617; . | BLExAR RX. &#8617; . | . ",
    "url": "/3.Project%20Charter.html#project-charter-the-plant-sitter",
    
    "relUrl": "/3.Project%20Charter.html#project-charter-the-plant-sitter"
  },"3": {
    "doc": "Project Charter",
    "title": "Project Charter",
    "content": " ",
    "url": "/3.Project%20Charter.html",
    
    "relUrl": "/3.Project%20Charter.html"
  },"4": {
    "doc": "Project Results",
    "title": "Project Results",
    "content": ". | Project Repository | Overview of Plant Sitter | Code . | Included Libraries | Global Declarations | writeBLE | setup | writeMenu | getData | writeCharacteristicHandler | waterNow | closeShade | openShade | heatOn | getDtSkip | loop | . | Validation | Future Work | . Project Repository . All firmware can be found at the Git Hub repository linked through the following button. Go to Repository . Overview of Plant Sitter . The Plant Sitter is a BLE device that operates as “idle state central device, active state peripheral device,” or “ICAP”. This allows it to utilize the low power consumption that BLE protocol offers, while being able to swtich between being both host and client. In its idle state as a central device, it continuously logs data about the environment, user inputs, and its own actions to its on board memory. When connection is made with a peripheral device, it offers a menu of choices to the user, receives and handles choices appropriately. If the choice “View/Export Data” is received, the Plant Sitter restarts its BLE service in Peripheral Mode. Once switched, the Plant Sitter broadcasts live data for about 10 minutes It then let’s the user know that it will be switching back to data logging mode, and goes back to central mode where it can receive new requests. [IMAGE HERE] . This device is a demonstration of how Bluetooth protocls can be used to wirelessly communicate with a single Plant Sitter. While BLE is used for this device, classic Bluetooth could be employed to increase the tranmission distance to the desired 100 m. This number comes from the popular unit of area for land, the hectare [100 m x 100 m], where the density of a potentiostat’s sensnsing arary could be expected to be about 1 sensing node per hectare. Therefore, assuming a grid-like implementation, one Plant Sitter would only be needed ever 4 hectares. Code . This section is devoted to showcasing the code as well as deep commenting. For an easily downloadable and useable version of the code, please visit the GitHub Repository located at the URL at the top of the page. Included Libraries . The only required libraries include the drivers for the sensors, clock, BLE, SD, and SPI. All other components can be controlled or communicated with via digital and analog reads. #include &lt;Arduino_HS300x.h&gt;//onboard temp/humidity sensor #include &lt;Arduino_LPS22HB.h&gt;//onboard barometer #include &lt;Adafruit_AS7341.h&gt;//10 channel spectrometer #include \"RTClib.h\"//clock #include &lt;SPI.h&gt;//Protocol for SPI #include &lt;SD.h&gt;//Protocol for file system #include &lt;Wire.h&gt;//Protocol for I2C #include &lt;ArduinoBLE.h&gt;//Protocol for BLE . Global Declarations . Here we declare at the top of the code two different types of BLE characteristics required for ICAP. By default it will chose “receive” unless there are errors connecting to peripherals or the user specifically requested it go to “transfer” Global variables with no default value are often populated from the attached SD card which acts as nonvolatile memory. //BLE Definitions BLEService myService(\"0000ffe0-0000-1000-8000-00805f9b34fb\"); // service characteristic BLECharacteristic receive(\"EFE5\", BLEIndicate | BLEWriteWithoutResponse ,0x20); BLECharacteristic transfer(\"FFE1\", BLEWrite | BLENotify,0x10); char bleMode; // will be t or r int wake; //Instrument Definitions/Pin Assignments Adafruit_AS7341 as7341; RTC_PCF8563 rtc; int sd = 2;//SD card CS pin int pumpPin = 27;//pin pump vcc is connected to int heatPin = 21;//pin heating pad is connected to int shade0 = 23;//pin for motor enable [can be 3V] as long as Vs and Vss are 5V https://www.arduino.cc/documents/datasheets/H-bridge_motor_driver.PDF int shade1 = 14;//pin for motor direction 1 int shade2 = 13;//pin for motor direction 2 int moist = 4;//pin for ADC reading of soil sensor int reset = 11; //pin attached to reset pin int calSoil = 15;//pin for callibrating soil moisture sensor int klock = 12;//pin to check int R = 22;//onboard RGB LED int G = 23;//onboard RGB LED int B = 24;//onboard RGB LED File myFile; //Global Variables int skip;//number of measurements to skip int dt;//measurement interval in ms float t;//temperature value float rh;//relative humidity value float p;//pressure value float VPD;//VPD value int soil;//soil moisture ADC reading float soilP;//soil moisture in percentage float setT;//temperature setpoint float setW;//soil set point int soilDry;//soil dry end callibration value int soilWet;//soil wet end callibration value int instErr[]={0, 0, 0, 0};//error on T&amp;RH, P, PAR, and SD . writeBLE . This function can be used in both modes to send strings to the phone app. byte plain[message.length()]; // message buffer message.getBytes(plain, message.length()); // convert to bytes receive.writeValue(plain,message.length()); . setup . Setup is responsible for a lot of things including normal stuff like setting pin modes and initializing instruments, but also for checking if the user is trying to callibrate the clock or soil sensor, and doing those callibrations before moving on. It also initalizes the SD card and uses values from pre-loaded files to populate global variables like setpoints for soil moisture and temperature. The most important things it does is begins the BLE service in the correct mode. By default, it will be set to act in RX mode where it is reading/receiving information from the phone. However, if it receives a request to push data to the phone, it softresets itself in transmit mode. While in transmission mode, it cannot take in commands, and it, currently, set to show the user 10 live data points [at whatever interval the measurement invertal is set to] before timing out and switching back to receiving mode. While in transmission mode, however, it does continue to log and save the data being sent to the user. An important variable, WAKE, is called in this function before BLE is advertised. This WAKE variable will be discussed in a later section dealing with how the Plant Sitter handles requests. //Set Pin Modes pinMode(klock,INPUT); pinMode(R, OUTPUT); pinMode(G, OUTPUT); pinMode(B, OUTPUT);//Set RBG Pins pinMode(moist,INPUT); pinMode(pumpPin, OUTPUT); pinMode(shade0, OUTPUT); pinMode(shade1, OUTPUT); pinMode(shade2, OUTPUT); digitalWrite(pumpPin,LOW); digitalWrite(shade0,LOW); digitalWrite(reset,HIGH);//Active High [not being reset] //Start and Set Clock time //If we're programming the board for the first time, its connected to Serial and will get the current date/time from the computer uploading the firmware if (digitalRead(klock)){//This will be false later when the jumper wire is removed/cut before packaging the circuit into its housing Serial.begin(115200); if (!rtc.begin()){ Serial.println(\"Error connecting to the RTC. Makesure clock pin is shorted high\"); } else { rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); } } else {rtc.begin();} //Note that because the clock will be set before packaging, there is no error handling for this. It either works or it doesn't //Initialize SD Card to decide if device /should/ be receiving [default] or sending data if (!SD.begin(sd)){//If SD doesn't begin, raise error flag, turn on LED, keep going in transmit mode so we can see what the error is from a phone digitalWrite(R, LOW);//active low bleMode = 't';//default to sending information instErr[3]=1;//raise error flag } else{//Otherwise the SD card began and we can at least /try/ to see what mode we wanted to be in myFile = SD.open(\"BLE.txt\");//File on pre-formattted/written SD card to store t or r; if (myFile.available()){ bleMode = myFile.peek();//there should be only be t or r. Peek allows me to check multiple times at the same location in the event a line break or extra character is present myFile.close(); } } //Callibrate the Soil Moisture sensor if (digitalRead(calSoil)){ Serial.begin(115200); Serial.println(\"Change Serial to 'No Line Ending' then Put Sensor in Dry State\"); delay(10000); Serial.println(\"When Satisfied Send Any Message Over Serial\"); while(Serial.available()){ soilDry = analogRead(moist); Serial.println(String(soil)); delay(500); } myFile = SD.open(\"soilDry.txt\",O_WRITE);//File on pre-formattted/written SD card to store t or r; myFile.print(String(soilDry)); myFile.close(); Serial.println(\"Now Submerge Sensor in Wet State\"); delay(10000); Serial.println(\"When Satisfied Send Any Message Over Serial\"); while(Serial.available()){ soilWet = analogRead(moist); Serial.println(String(soil)); delay(500); } myFile = SD.open(\"soilWet.txt\",O_WRITE);//File on pre-formattted/written SD card to store t or r; myFile.print(String(soilWet)); myFile.close(); } //Initialize instruments; if one doesn't work, Red LED will turn on and instErr value will turn from 0 to 1; Also populate the desired setPoints from files //Initialize the temp/humidity sensor. It should just work because this is inside the uC if (!HS300x.begin()) { digitalWrite(R,LOW);//active low bleMode='t'; instErr[0]=1; } myFile = SD.open(\"tsp.txt\");//File on pre-formattted/written SD card to store t or r; String tempSP=\"\"; while(myFile.available()){ tempSP = tempSP + (char)myFile.read(); } setT = tempSP.toFloat(); //Populate Soil Moisture Set Point myFile = SD.open(\"wsp.txt\");//File on pre-formattted/written SD card to store t or r; String soilSP=\"\"; while(myFile.available()){ soilSP = soilSP + (char)myFile.read(); } setW = soilSP.toFloat(); //Initialize the barometer if (!BARO.begin()) { digitalWrite(R,LOW);//active low bleMode='t'; instErr[1]=1;} //Initialize the PAR meter if (!as7341.begin()){ digitalWrite(R,LOW);//active low bleMode='t'; instErr[2]=1; } as7341.setATIME(100); as7341.setASTEP(999); as7341.setGain(AS7341_GAIN_256X); //Initialize DataAquisition Variables getDtSkip(); //Initalize BLE based on requested mode/Service //Start up BLE and flash blue LED while (!BLE.begin()) { //Blink blue LED while waiting for BLE to start digitalWrite(B, LOW); delay(500); digitalWrite(B, HIGH); delay(500); } //Add approprite characteristic to service if (bleMode == 't'){ myService.addCharacteristic(transfer); } else { myService.addCharacteristic(receive); } BLE.addService(myService); // add service to BLE dev BLEAdvertisingData scanData; // Build scan response data packet if (bleMode =='r'){ scanData.setLocalName(\"PlantSitterRemote\"); // set BLE name BLE.setDeviceName(\"PlantSitterRemote\"); // set BLE name } else { scanData.setLocalName(\"PlantSitterData\"); // set BLE name BLE.setDeviceName(\"PlantSitterData\"); // set BLE name } BLE.setScanResponseData(scanData); // set name for scanners //Start handler if needed if (bleMode == 'r'){//this isn't needed for transmitting data because we don't need an event handler when sending things receive.setEventHandler(BLEWritten, WriteCharacteristicHandler); // add written handler } //Advertise BLE wake = 0;//we only just started so the user is likely only just signing on! BLE.advertise(); // advertise BLE from MakerBLE board //If in transmission mode, send data to phone and restart if (bleMode == 't'){ int stay = 0; int timeOUT = dt*10; //Declare self a central device BLEDevice central = BLE.central(); if (central) {//if a connection is made //check if there are any errors we need to make alerts about int errCheck=0; for (int i=1; i &lt;=4; i++){ errCheck=errCheck + instErr[i]; } //If errors, ONLY ADVERTISE which things are in error. Wait for physical restart if (errCheck&gt;0){ while (central.connected()){ for (int i=1; i &lt;=4; i++){ switch(i){ case 1: if (instErr[i] == 1){ writeBLE(\"Temperature and Humidity Sensor Error\");} break; case 2: if (instErr[i] == 1){ writeBLE(\"Pressure Sensor Error\");} break; case 3: if (instErr[i] == 1){ writeBLE(\"Light Sensor Error\");} break; case 4: if (instErr[i] == 1){ writeBLE(\"SD Card Error\");} break; } delay(500); } } //If no errors, send/save data normally. } else { while (central.connected() &amp;&amp; stay &lt;10) { //Get data, save, display, and try to fix values far from set points since we are not able to control them in TX mode[Could honestly be in a function or something idk...] String strToPrint = \"\"; // string to print //Save the time digitalWrite(G,LOW); myFile = SD.open(\"DATA.txt\",FILE_WRITE); DateTime now = rtc.now(); myFile.print(now.year(), DEC); myFile.print(','); strToPrint+= String(now.year());strToPrint+=\",\"; myFile.print(now.month(), DEC); myFile.print(','); strToPrint+= String(now.month());strToPrint+=\",\"; myFile.print(now.day(), DEC); myFile.print(','); strToPrint+= String(now.day());strToPrint+=\",\"; myFile.print(now.hour(), DEC); myFile.print(','); strToPrint+= String(now.hour());strToPrint+=\",\"; myFile.print(now.minute(), DEC); myFile.print(','); strToPrint+= String(now.minute());strToPrint+=\",\"; myFile.print(now.second(), DEC); myFile.print(','); strToPrint+= String(now.second());strToPrint+=\",\"; //Save Temperature float t = HS300x.readTemperature();//get temp in C myFile.print(String(t,2)); myFile.print(','); strToPrint+= String(t,2);strToPrint+=\",\"; if (t&lt;=setT*0.90){ heatOn(); } //Save Soil Moisture soil = analogRead(moist); soilP = soil/(soilWet-soilDry); myFile.print(String(soilP,2)); if (soilP&lt;=setW*0.50){ waterNow(); } //Save RH float rh = HS300x.readHumidity();//get RH as % myFile.print(String(rh,2)); myFile.print(','); strToPrint+= String(rh,2);strToPrint+=\",\"; //Save Pressure float p = BARO.readPressure();//get pressure in kPa myFile.print(String(p/1000,2)); myFile.print(','); strToPrint+= String(p,2);strToPrint+=\",\"; //Save VPD float e = 17.2694*t/(t+237.3);//figure out dew point float eu = 2.71828; float psat = 610.78*pow(eu , e);//from dewpoint figure out psat float pw = psat*(1-(rh/100));//now figure out how much your vpd is float mpa = pw/1000;//unit conversion myFile.print(String(mpa/1000,2)); myFile.print(','); strToPrint+= String(mpa,2);strToPrint+=\",\"; //Save Light Readings //Max reading is 65535 uint16_t readings[12]; as7341.readAllChannels(readings); myFile.print(String(readings[0]));//415nm myFile.print(','); strToPrint+= String(readings[0]);strToPrint+=\",\"; myFile.print(String(readings[1]));//445nm myFile.print(','); strToPrint+= String(readings[1]);strToPrint+=\",\"; myFile.print(String(readings[2]));//480 nm myFile.print(','); strToPrint+= String(readings[2]);strToPrint+=\",\"; myFile.print(String(readings[3]));//515 nm myFile.print(','); strToPrint+= String(readings[3]);strToPrint+=\",\"; myFile.print(String(readings[6]));//555 nm myFile.print(','); strToPrint+= String(readings[6]);strToPrint+=\",\"; myFile.print(String(readings[7]));//590 nm myFile.print(','); strToPrint+= String(readings[7]);strToPrint+=\",\"; myFile.print(String(readings[8]));//630 nm myFile.print(','); strToPrint+= String(readings[8]);strToPrint+=\",\"; myFile.print(String(readings[9]));//680 nm myFile.print(','); strToPrint+= String(readings[9]);strToPrint+=\",\"; myFile.print(String(readings[11]));//IR @ 910 nm myFile.print(','); strToPrint+= String(readings[11]);strToPrint+=\",\"; myFile.print(String(readings[10]));//white myFile.print(','); strToPrint+= String(readings[10]);strToPrint+=\",\"; //Save Actions myFile.print('0');//watered myFile.print(','); strToPrint+= String('0');strToPrint+=\",\"; myFile.print('0');//shade myFile.print(','); strToPrint+= String('0');strToPrint+=\",\"; myFile.println('0');//heat strToPrint+= String('0');strToPrint+=\"\\n\"; //close file and send data myFile.close(); writeBLE(strToPrint); digitalWrite(G,HIGH); //Delay and incriment stay before starting over delay(dt); stay=stay+1; } myFile = SD.open(\"BLE.txt\",O_WRITE); myFile.print(\"r\"); myFile.close(); writeBLE(\"Returning to Remote Mode in 5\"); delay(1000); writeBLE(\"4\"); delay(1000); writeBLE(\"3\"); delay(1000); writeBLE(\"2\"); delay(1000); writeBLE(\"1\"); delay(1000); writeBLE(\"Goodbye\"); delay(500); digitalWrite(reset,LOW); } } //RESET THE DEVICE IF CENTRAL DISCONNECTS digitalWrite(reset,LOW); } . writeMenu . This function is called on a few times, but is separated to be easily accessible for future editing. Here you can see the list of commands a user can request of the Plant Sitter while its in receiving/remote mode . writeBLE(\"Welcome to Plant Sitter! Choose an action:\"); writeBLE(\"[1] Water the Plant\"); writeBLE(\"[2] Move the Shade\"); writeBLE(\"[3] Change a Set Point\"); writeBLE(\"[4] Change the Schedule\"); writeBLE(\"[5] View/Export Data\"); . getData . This is the workhorse function of the Plant Sitter. It logs all of the environmental data, and takes in three arguements as a function. The boolean represents if, during the measurements, we want to ask the Plant Sitter to try to fix something, like if the soil is too dry or cold. The three integers can be either 0 or 1, representing if getData was called during a point when the water was turned on, the shade was moved, or the heat was turned on. If the user changes one of these things, they will naturally grab a data point right beforehand to snapshot the time point any of these changes were made. However, in these instances, since the Plant Sitter is already fixing something, fix is set to false making sure other actions are called again without being requested. [otherwise getData and the function watering the plant would form a loop calling eachother.] . The Plant Sitter will only autonomously fix things if the user isn’t present. void getData(int a, int b, int c, bool fix){ //Save the time digitalWrite(G,LOW); myFile = SD.open(\"DATA.txt\",FILE_WRITE); DateTime now = rtc.now(); myFile.print(now.year(), DEC); myFile.print(','); myFile.print(now.month(), DEC); myFile.print(','); myFile.print(now.day(), DEC); myFile.print(','); myFile.print(now.hour(), DEC); myFile.print(','); myFile.print(now.minute(), DEC); myFile.print(','); myFile.print(now.second(), DEC); myFile.print(','); //Save Temperature float t = HS300x.readTemperature();//get temp in C myFile.print(String(t,2)); myFile.print(','); if (t&lt;=setT*0.45 &amp;&amp; fix){ //if SP 25 and temp drops to 15, [~75F to ~50F] heatOn(); } //Save Soil Moisture soil = analogRead(moist); soilP = soil/(soilWet-soilDry); myFile.print(String(soilP,2)); if (soilP&lt;=setW*0.90 &amp;&amp; fix){ waterNow(); } //Save RH float rh = HS300x.readHumidity();//get RH as % myFile.print(String(rh,2)); myFile.print(','); //Save Pressure float p = BARO.readPressure();//get pressure in kPa myFile.print(String(p/1000,2)); myFile.print(','); //Save VPD float e = 17.2694*t/(t+237.3);//figure out dew point float eu = 2.71828; float psat = 610.78*pow(eu , e);//from dewpoint figure out psat float pw = psat*(1-(rh/100));//now figure out how much your vpd is float mpa = pw/1000;//unit conversion myFile.print(String(mpa/1000,2)); myFile.print(','); //Save Light Readings //Max reading is 65535 uint16_t readings[12]; as7341.readAllChannels(readings); myFile.print(String(readings[0]));//415nm myFile.print(','); myFile.print(String(readings[1]));//445nm myFile.print(','); myFile.print(String(readings[2]));//480 nm myFile.print(','); myFile.print(String(readings[3]));//515 nm myFile.print(','); myFile.print(String(readings[6]));//555 nm myFile.print(','); myFile.print(String(readings[7]));//590 nm myFile.print(','); myFile.print(String(readings[8]));//630 nm myFile.print(','); myFile.print(String(readings[9]));//680 nm myFile.print(','); myFile.print(String(readings[11]));//IR @ 910 nm myFile.print(','); myFile.print(String(readings[10]));//white myFile.print(','); //Save Actions myFile.print(String(a));//watered myFile.print(','); myFile.print(String(b));//shade myFile.print(','); myFile.println(String(c));//heat //close file myFile.close(); digitalWrite(G,HIGH); } . writeCharacteristicHandler . This is the code behind the Plant Sitter’s ability to speak. At its highest level, it uses the WAKE variable, declared in setup, to handle the main menu choice. Wake is then used as the argument of the top layer of swtich statements. NOTE that there are more cases for wake than there are choices. This is because some menu choices bring the user to another menu. In these events, wake is set to numbers larger than there are main menu options so that submenu choices are handled correctly. Wake is initialized to be 0 in setup, and so as soon as someone sends anything to the Plant Sitter, it offers the menu of choices to the user, and switches wake to 1. After the menu is written, and wake=1, further inputs are expected to be integers representing choices. [Note, the user can accidentally skip to a submenu by inputting a higher integer at this version of the code, but choices of wake that are not integers or higher than possible integers will produce no response and the handler will loop.] . While wake=1, if another 1 is chosen, the Plant Sitter will let the user know it is watering the plant. However is 2 is chosen, the Plant Sitter will first check what the position of the shade is by looking at the SD card’s text file holding the shade’s current position, and then move the shade to the opposite location [either shading or open (d for dark or b for bright)]This type of check with the SD card is the way that the Plant Sitter retains its memory despite having to power cycle itself. To that effect, the desired set point for soil moisture and temperature can be reset by accessing submenus in the handler cascade which eventually look for recognizable floats. Finally, the user can request that the Plant Sitter show the user its live readings by having the Plant Sitter switch over to tx mode. To do this, it first rewrites the BLE file to contain the character t instead of r, which it checks on when starting up BLE in the setup function. It counts down, and then pulls its own reset button low to power cycle itself. Now, when it runs the setup function, it not only knows to set itself up in transmission mode, but it in fact never leaves the setup function before power cycling itself again after logging, saving, and displaying 10 data points, followed by resetting BLE.txt to contain r instead of t. If I had more time to learn cpp, I honestly could have made this entire code its own library [which frankly it should have been for better useability but here we are] . char status;//menu-global variable that we can redeclare each time the handler is called switch (wake){ case 0://Send Menu Options and Wait for Choice { writeMenu();//Write Menu Options to App wake = 1;//you've now sent the menu options at least once break; } case 1://handle menu selection { String inputText1 = (char*)receive.value(); // read incoming data int choice1 = inputText1.toInt(); switch (choice1){ case 1://water the plant { writeBLE(\"Applying @300 ml of Water over 5 seconds\");//let the user know their command has been received digitalWrite(G,LOW); getData(1,0,0,false); waterNow(); digitalWrite(G,HIGH); wake==0; break;//break choice 1.1 } case 2://Change shade position { myFile = SD.open(\"shade.txt\");//File on pre-formattted/written SD card to store b or d for bright or dark; if (myFile.available()){ status = myFile.peek();//there should be only be t or r. Peek allows me to check multiple times at the same location in the event a line break or extra character is present myFile.close(); } getData(0,1,0,false); if (status == 'b'){ digitalWrite(G,LOW); closeShade(); digitalWrite(G,HIGH); myFile = SD.open(\"shade.txt\", O_WRITE);//Overwrites the file myFile.print(\"d\"); myFile.close(); } else { digitalWrite(G,LOW); openShade(); digitalWrite(G,HIGH); myFile = SD.open(\"shade.txt\", O_WRITE);//Overwrites the file myFile.print(\"b\"); myFile.close(); } wake==0; break;//break choice 1.2 } case 3://change a set point { writeBLE(\"The current setpoints for Temperature and Water are: \");//let the user know their command has been received writeBLE(String(setT,2)); writeBLE(\"and\"); writeBLE(String(setW,2)); writeBLE(\"Change a Set Point?\"); writeBLE(\"[1] Change Temperature Set Point:\"); writeBLE(\"[2] Change Soil Moisture Set Point:\"); writeBLE(\"[3] Return to Menu\"); wake==2; break;//break choice 1.3 } case 4://change schedule { int dtmin = dt/1000/60; String interval = String(dtmin); int pausetime = dtmin*skip; String pause = String(pausetime); writeBLE(\"The current measurement interval is: \"+interval+\" minutes.\"); writeBLE(\"Automation is paused for \"+pause+\" more minutes.\"); writeBLE(\"Change Schedule?\"); writeBLE(\"[1] Yes\"); writeBLE(\"[2] No\"); wake=5; break;//break 1.4 } case 5://export data { writeBLE(\"Would you like to disconnect from Remote Control\"); writeBLE(\"and reconnect to in Data View?\"); writeBLE(\"[1] Stay in Remote Control\"); writeBLE(\"[2] Go to Data View\"); wake=8; break;//break 1.5 } }//end menu choice switch break;//break wake case 1 }//end wake case 1 case 2://Change which set point? { String inputText2 = (char*)receive.value(); // read incoming data int choice2 = inputText2.toInt(); switch(choice2) { case 1: wake = 3; writeBLE(\"Enter New Set Point as ## C\"); break;//temperature case 2: wake = 4; writeBLE(\"Enter New Set Point as 0.##\"); break;//water case 3: wake = 0; break;//neither } break;//break wake 2 } case 3://change temp setpoint { String inputText3 = (char*)receive.value(); // read incoming data float tsp = inputText3.toFloat(); myFile = SD.open(\"tsp.txt\",O_WRITE); if (myFile.available()){ myFile.print(inputText3);} myFile.close(); writeBLE(\"New Temperature Set Point: \"+inputText3+\" in degrees C\"); wake==0; break;//break wake 3 } case 4://change water setpoint { String inputText4 = (char*)receive.value(); // read incoming data float wsp = inputText4.toFloat(); myFile = SD.open(\"wsp.txt\",O_WRITE); if (myFile.available()){ myFile.print(inputText4);} myFile.close(); writeBLE(\"New Watering Set Point: \"+inputText4+\" % to Max Soil Moisture\"); wake==0; break;//break wake 4 } case 5://handle schedule submenu { String inputText5 = (char*)receive.value(); // read incoming data int choice5 = inputText5.toInt(); switch(choice5) { case 1:// change schedule wake = 6; writeBLE(\"Pick the new measurement interval in minutes [ints only]\"); break; case 2:// return to menu wake = 0; break; } break;//break wake 5 } case 6://change dt { String inputText6 = (char*)receive.value(); // read incoming data int delayMin = inputText6.toInt(); dt = delayMin*60*1000; myFile = SD.open(\"dt.txt\",O_WRITE); if (myFile.available()){ myFile.print(inputText6);} myFile.close(); writeBLE(\"New dt set to: \"+inputText6+\" minutes\"); writeBLE(\"Skip automation for how many minutes?\"); wake = 7; break;//break wake 6 } case 7://change skip { String inputText7 = (char*)receive.value(); // read incoming data int skipMin = inputText7.toInt(); float skipNum = skipMin/dt; skip = round(skipNum); String skipLog = String(skip); myFile = SD.open(\"skip.txt\",O_WRITE); if (myFile.available()){ myFile.print(skipLog);} myFile.close(); writeBLE(\"Automation will be paused for \"+inputText7+\" more minutes\"); wake=0; break; } case 8://confirm switching mode String inputText8 = (char*)receive.value(); // read incoming data int choice8 = inputText8.toInt(); switch(choice8){ case 1: wake = 0; break; case 2: writeBLE(\"Plant Sitter is Getting Ready to Switch to Data View&amp;Export Mode\"); getData(0,0,0,true); writeBLE(\"Plant Sitter is Saving State\"); myFile = SD.open(\"BLE.txt\",O_WRITE);//File on pre-formattted/written SD card to store t or r; myFile.write(\"t\"); myFile.close(); writeBLE(\"Plant Sitter will restart in Data View&amp;Export Mode in\"); writeBLE(\"10\"); delay(1000); writeBLE(\"9\"); delay(1000); writeBLE(\"8\"); delay(1000); writeBLE(\"7\"); delay(1000); writeBLE(\"6\"); delay(1000); writeBLE(\"5\"); delay(1000); writeBLE(\"4\"); delay(1000); writeBLE(\"3\"); delay(1000); writeBLE(\"2\"); delay(1000); writeBLE(\"1\"); delay(1000); writeBLE(\"Goodbye!\"); digitalWrite(reset, LOW);//cycle uC break;//breaks case 2 }//ends subchoice switch break;//ends case 8 }//end wake switch . waterNow . digitalWrite(pumpPin,HIGH); delay(5000);//time required to deliver 300 ml of water based on calculations/assumptions below digitalWrite(pumpPin,LOW); //Time calculation for water /*Assumptions Pump rated at 0.1 amps Assume 3 V applied It takes 10 Pascals to lift water 1 mm Assume pump located 0.5 m below delivery point ============================================== P=IV -&gt; 0.3 Watts == 0.3 N*m/s Must exert 5000 Pa == 5000 N/m*m Unit wise: (N*m*m*m) / (N*s) - &gt; m^3 / s 0.3/5000 = 0.00006 cubic meters of water per second or 60 ml per second */ . closeShade . digitalWrite(shade1,HIGH);//Set up motor direction digitalWrite(shade2,LOW); digitalWrite(shade0,HIGH); delay(5000);//a resistor over motor pins will ensure the motor speed is appropriate to move in 5 seconds digitalWrite(shade0,LOW); writeBLE(\"Shade Closed\"); . openShade . digitalWrite(shade1,LOW);//Set up motor direction digitalWrite(shade2,HIGH); digitalWrite(shade0,HIGH); delay(5000);//a resistor over motor pins will ensure the motor speed is appropriate to move in 5 seconds digitalWrite(shade0,LOW); writeBLE(\"Shade Opened\"); . heatOn . for (int j=0;j&lt;10;j++){ digitalWrite(heatPin,HIGH); delay(500); digitalWrite(heatPin,LOW); delay(500); } . getDtSkip . This function is responsible for determining how frequently the Plant Sitter should log data data. It is sort of a “pseudo clock” that exists on a higher level than the microcontroller’s true clock or the rtc. Similar to the delay value of the Blink’s loop function. Note we don’t use the RTC for this, we just assume that on time scales of 1 minute upwards to multiple minutes or hours, that its “accurate enough.” . myFile = SD.open(\"dt.txt\");//File on pre-formattted/written SD card to store t or r; String timeInt; while (myFile.available()){ timeInt=timeInt + (char)myFile.read(); } myFile.close(); int timeInterval = timeInt.toInt(); dt = 60*1000*timeInterval; ///now get skip/// myFile = SD.open(\"skip.txt\");//File on pre-formattted/written SD card to store t or r; String ignore; while (myFile.available()){ ignore=ignore + (char)myFile.read(); } myFile.close(); skip = ignore.toInt(); . loop . This is our listener function that the microcontroller only gets to if its in receive/remote/RX mode. BLE.poll() listens for data over BLE, but will timeout after its argument number of milliseconds has passed. If no requests have come by then, it will log data every dt milliseconds and either try to fix any issues it notices if automatiion is active, or inciment its skip index and not fix things if the number of skips is still greater than 0. Note that, if a user is connected to the remote and makes no choices for a time period greater than dt, the Plant Sitter will be unable to automatically log data as it would be busy listening for BLE responses in the handler function! . We hope that a user would try to make their changes/requests in either under that time frame, or chose actions that inherently log data themselves [ie watering the plant, heating the plant, or changing the shade postion all call getData since the request for such events themselves are logged]. Additionally, if the user is requesting to view/export data, as long as they reconnect to the Plant Sitter in a reasonable amount of time, data is still logged while the Plant Sitter is transmitting readings. //while we're not activley taking a measurement, see if there are incoming messages over BLE BLE.poll(dt);//wait for an event over BLE until we need to use thinking power to grab the new data set //When its about time to take a measurement, get the data, and decrease the skip index if (skip == 0) { getData(0,0,0,true); } else { getData(0,0,0,false); skip = skip - 1; myFile = SD.open(\"skip.txt\",O_WRITE); String count = String(skip); myFile.print(count); myFile.close(); } . Validation . The easiest way to validate that this code works is to copy it to your own Arduino IDE 2.0.4 and compile it yourself. Just make sure all libraries included are installed in your IDE as well. To copy and paste this code or download it yourself, please visit the Git Hub Repository linked in the URL at the top of the page. Below, however, are pictures of a much simpler version of the code where the microcontroller loops through reporting data over BLE as “status messages” in rx mode, but can be switched to transmit mode where the BLExAR app will graph incoming data instead. pictures of BLExAR with onboard sensors . Future Work . This is the firmware for the Plant Sitter as described at https://mrenny.github.io/ArduinoMC/ intended for STANDALONE USE ONLY. IE, this is meant for personal, hobbyist use Future work on this device could include: *if VPD is extreme, shade plant to reduce wilt [requires knowledge of a good set point based on environment and plant species] *Make an extra layer of questioning in the handler, “how much data do you want to view/export” such that it retreives old data and not just activley populating data *look at time stamp requested and range of data. *Find/seek for that line of data in the data file. [or have set options where every file is intervals of like 12 hours and you can look at last 12,24,48, etc hours of data without pulling the SD card out] *populate the data points to BLExAR [note BLExAR does not let you choose the x axis [I don’t think] and I didn’t want to learn MIT app inventor for custom x axis stuff] ^this allows someone to view the most recent requested data, but not the real time data which should be fine for our purposes *Also ask how long you’d like to work with the data. It currently times out and resets back to remote mode after 5 minutes *Working with interupt statements of some sort so that data is taken at the correct intervals even when user inputs are being executed/listened for *Allow for automatic watering/shading/heating when in data viewing mode by fleshing out functions called in setup’s sort into transmit mode *Reformatting to cheaper ESP32-based boards like the Firebeetle which also offer WiFi with BLE *Established connections with handheld potentiostat [which itself is not yet finished] *User support for SD card storage limit warnings instead of assuming the user will export &amp; clear data at least annually *assuming 365 days, and twenty 4 byte numbers being stored, one year of data would be a little over 42 MB which is still perfectly manageable on commonly sized SD cards . Because we are working off the BLExAR phone app architecture, the app can only receive live data, not old data. However, this can be easily circumvented if the we simply command the Plant Sitter to simply send old data only. While this . ",
    "url": "/4.Project.html",
    
    "relUrl": "/4.Project.html"
  },"5": {
    "doc": "Home",
    "title": "The Plant Sitter: An Environmental Controller for Closed Loop Precision Agriculture",
    "content": "A project submitted to the Integrated Teaching and Learning Laboratory at the University of Colorado in partial fulfillment of the requirements for the Arduino Microcredential: Spring 2023 . ",
    "url": "/#the-plant-sitter-an-environmental-controller-for-closed-loop-precision-agriculture",
    
    "relUrl": "/#the-plant-sitter-an-environmental-controller-for-closed-loop-precision-agriculture"
  },"6": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  }
}
